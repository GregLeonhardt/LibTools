/*******************************  COPYRIGHT  ********************************/
/*
 *  By Steve Reid <sreid@sea-to-sky.net>
 *  100% Public Domain
 *  --------------
 *  Modified 7/98
 *  By James H. Brown <jbrown@burgoyne.com>
 *  Still 100% Public Domain
 *  --------------
 *  Modified 8/98
 *  By Steve Reid <sreid@sea-to-sky.net>
 *  Still 100% public domain
 *  --------------
 *  Modified 4/01
 *  By Saul Kravitz <Saul.Kravitz@celera.com>
 *  Still 100% PD
 *  Modified to run on Compaq Alpha hardware.
 *  --------------
 *  Modified 07/2002 By Ralph Giles <giles@ghostscript.com>
 *  Still 100% public domain
 *  --------------
 *  Modified 09/2012 By Greg Leonhardt <Greg.Leonhardt@Oracle.com>
 *  Still 100% public domain
 *
 ****************************************************************************/

/******************************** JAVADOC ***********************************/
/**
 *  By Steve Reid <sreid@sea-to-sky.net>
 *  100% Public Domain
 *  --------------
 *  Corrected a problem which generated improper hash values on 16 bit machines
 *  Routine SHA1Update changed
 *  from:
 *      void
 *      SHA1Update(
 *          SHA1_CTX        *   context,
 *          unsigned char   *   data,
 *          unsigned int        len
 *          );
 *  to:
 *      void
 *      SHA1Update(
 *          SHA1_CTX        *   context,
 *          unsigned char   *   data,
 *          unsigned long       len
 *          );
 *
 *  The 'len' parameter was declared an int which works fine on 32 bit
 *  machines. However, on 16 bit machines an int is too small for the shifts
 *  being done against it.  This caused the hash function to generate
 *  incorrect values if len was greater than 8191 (8K - 1) due to the 'len <<
 *  3' on line 3 of SHA1Update().
 *
 *  Since the file IO in main() reads 16K at a time, any file 8K or larger
 *  would be guaranteed to generate the wrong hash (e.g. Test Vector #3,
 *  a million "a"s).
 *
 *  I also changed the declaration of variables ndx_1 & ndx_2 in SHA1Update to
 *  unsigned long from unsigned int for the same reason.
 *
 *  These changes should make no difference to any 32 bit implementations
 *  since an int and a long are the same size in those environments.
 *
 *  --------------
 *
 *  I also corrected a few compiler warnings generated by Borland C.
 *      1. Added #include <process.h> for exit() prototype
 *      2. Removed unused variable 'j' in SHA1Final
 *      3. Changed exit(0) to return(0) at end of main.
 *
 *  ALL changes I made can be located by searching for comments containing
 *  'JHB'
 *
 *  --------------
 *
 *  Modified 8/98
 *  By Steve Reid <sreid@sea-to-sky.net>
 *  Still 100% public domain
 *
 *      1 - Removed #include <process.h> and used return() instead of exit()
 *      2 - Fixed overwriting of finalcount in SHA1Final() (discovered by
 *          Chris Hall)
 *      3- Changed email address from steve@edmweb.com to sreid@sea-to-sky.net
 *
 *  --------------
 *
 *  Modified 4/01
 *  By Saul Kravitz <Saul.Kravitz@celera.com>
 *  Still 100% PD
 *
 *  Modified to run on Compaq Alpha hardware.
 *
 *  --------------
 *
 *  Modified 07/2002
 *  By Ralph Giles <giles@ghostscript.com>
 *  Still 100% public domain
 *
 *  Modified for use with stdint types, autoconf code cleanup, removed
 *  attribution comments switched SHA1Final() argument order for consistency
 *  use SHA1_ prefix for public api move public api to sha1.h
 *
 *  --------------
 *
 *  Modified 09/2012 By Greg Leonhardt <Greg.Leonhardt@Oracle.com>
 *  Still 100% public domain
 *
 *      *   Cleanup of the 'VERBOSE' compile flag and calling
 *          'SHA1__PrintContext()'.
 *      *   Changed how 'SHA1HANDSOFF' is used.
 *      *   Reformatted the source file to conform to UTF Coding Standards.
 *      *   Added definition for 'WORDS_BIGENDIAN' on SPARC servers.
 *
 *  @note
 *
 ****************************************************************************/

/****************************************************************************
 *  Compiler directives
 ****************************************************************************/

#define ALLOC_SHA1              ( "ALLOCATE STORAGE FOR SHA1" )

/*
 *  Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
 *  significant byte first (like Motorola and SPARC, unlike Intel and VAX).
 */
#if defined __sparc
    #define WORDS_BIGENDIAN 1
#elif ! defined __sparc
    #undef WORDS_BIGENDIAN
#endif

/****************************************************************************
 * System Function API
 ****************************************************************************/

                                //*******************************************
#ifdef HAVE_CONFIG_H
    #include "config.h"         //
#endif

#include <stdio.h>              //  File input and output
#include <string.h>             //  String copying, searching, etc.
#include <stdint.h>             //  uint??_t
#include <stddef.h>             //  size_t
                                //*******************************************

/****************************************************************************
 * Application APIs
 ****************************************************************************/

                                //*******************************************
#include <libtools_api.h>       //  Everything public
                                //*******************************************
#include "sha1_lib.h"           //  API for all SHA1__*             PRIVATE
                                //*******************************************

/****************************************************************************
 * API Enumerations
 ****************************************************************************/

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************
 * Private Definitions
 ****************************************************************************/

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************
 * Private Structures
 ****************************************************************************/


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************
 * Private Storage Allocation
 ****************************************************************************/

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************
 * Private Storage Allocation to this file
 ****************************************************************************/

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/****************************************************************************/

/****************************************************************************
 * Public Functions
 ****************************************************************************/

/****************************************************************************/
/**
 *  SHA1Init - Initialize new context
 *
 *  @param  context             .
 *
 *  @return void
 *
 ****************************************************************************/

void
sha1_init(
    SHA1_CTX                    *   context
    )
{
    /* SHA1 initialization constants */
    context->state[ 0 ] = 0x67452301;
    context->state[ 1 ] = 0xEFCDAB89;
    context->state[ 2 ] = 0x98BADCFE;
    context->state[ 3 ] = 0x10325476;
    context->state[ 4 ] = 0xC3D2E1F0;
    context->count[ 0 ] = context->count[ 1 ] = 0;
}

/****************************************************************************/
/**
 *  Run your data through this.
 *
 *  @param  context             .
 *  @param  data                .
 *  @param  len                 .
 *
 *  @return void
 *
 ****************************************************************************/

void
sha1_update(
    SHA1_CTX                    *   context,
    const char                  *   data,
    const size_t                    len
    )
{
    size_t                          ndx_1;
    size_t                          ndx_2;

    //  Debug display.
    SHA1__PrintContext( context, (char*)"before" );

    ndx_2 = ( context->count[ 0 ] >> 3 ) & 63;

    if ( ( context->count[ 0 ] += len << 3) < (len << 3) ) context->count[ 1 ]++;
    {
        context->count[ 1 ] += ( len >> 29 );
    }
    if ( ( ndx_2 + len ) > 63 )
    {
        memcpy( &context->buffer[ ndx_2 ], data, ( ndx_1 = 64 - ndx_2 ) );
        SHA1__transform( context->state, context->buffer );

        for ( ;
              ndx_1 + 63 < len;
              ndx_1 += 64 )
        {
            SHA1__transform( context->state, (uint8_t*)data + ndx_1 );
        }
        ndx_2 = 0;
    }
    else
    {
        ndx_1 = 0;
    }
    memcpy( &context->buffer[ ndx_2 ], &data[ ndx_1 ], len - ndx_1 );

    //  Debug display.
    SHA1__PrintContext( context, (char*)"after " );
}

/****************************************************************************/
/**
 *  Add padding and return the message digest.
 *
 *  @param  context             .
 *  @param  digest              .
 *
 *  @return void
 *
 ****************************************************************************/

void
sha1_final(
    SHA1_CTX                    *   context,
    char                            digest[ SHA1_DIGEST_SIZE ] )
{
    uint32_t                        ndx_1;
    char                            finalcount[ 8 ];

    for ( ndx_1 = 0;
          ndx_1 < 8;
          ndx_1++ )
    {
        //  Endian independent
        finalcount[ ndx_1 ] = (unsigned char)( ( context->count[ ( ndx_1 >= 4 ? 0 : 1) ]
                                          >> ( ( 3 - ( ndx_1 & 3 ) ) * 8 ) ) & 255 );
    }

    sha1_update( context, (char *)"\200", 1 );

    while ( ( context->count[ 0 ] & 504) != 448)
    {
        sha1_update( context, (char *)"\0", 1 );
    }

    //  Should cause a SHA1__transform()
    sha1_update( context, finalcount, 8 );

    for ( ndx_1 = 0;
          ndx_1 < SHA1_DIGEST_SIZE;
          ndx_1++ )
    {
        digest[ ndx_1 ] = (uint8_t)( ( context->state[ ndx_1 >> 2 ] >> ( ( 3 - ( ndx_1 & 3 ) ) * 8 ) ) & 255 );
    }

    //  Wipe variables
    ndx_1 = 0;
    memset( context->buffer, 0, 64 );
    memset( context->state, 0, 20 );
    memset( context->count, 0, 8 );
    memset( finalcount, 0, 8 );   /* SWR */


#if SHA1HANDSOFF
    //  Make SHA1__transform overwrite its own static vars *
    SHA1__transform( context->state, context->buffer );
#endif
}

/****************************************************************************/
